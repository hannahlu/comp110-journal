# comp110-journal

<h3>Entry 1: When does a physical system compute?</h3>

Is everything a computer? The answer as far as Horsman C et al [1], are concerned, is no; not everything in the universe is acting as a computer.  They argue that declaring everything as a computer, negates the existence of physical computation in its own right and that a framework is needed for determining whether a physical system is performing a computation. The proposed requirements for a physical system to be performing a computation are as follows:

-	 A physical system can only be used as a computer, once we are confident of the physical theory of the device and are confident all the diagrams, proposed by Horsman C et al, commute. 
-	Confidence in the theory, is the confidence that within the known limits of the theory, all inputs and all programs will commute.
-	Central to their argument is the representation relation of the abstract to the physical and vice versa. Computers are used to solve an abstract problem. A physical system needs an abstract problem to be able to be embedded into the abstract description of the physical system. Unlike physics, where abstract entities are formed to represent the physical, computing involves taking an abstract quantity and representing it physically. The theory needs to be strong enough to perform the representation relation in both directions. A computational entity, which is responsible for representation relation, is also needed.
-	Without encoding and decoding, the physical system is not being used as a computer.

In conclusion, for a physical system to be able to perform a computation, the proposed requirements are: a strong physical theory of the computer, which we are confident with and have tested, a computational entity, a representation relation, ability to encode and decode information and one or more fundamental dynamical operations (such as logic gates) which are able to transfer input states to output states. Finally, all these elements need to pass the relevant commuting diagrams proposed.

<h3>Entry 2: Experimental Investigations of the Utility of Detailed Flowcharts in Programming.</h3>

In this paper, B.Shneiderman et al [2], set up five experiments to see if and how university students might benefit from the use of flowcharts in improving their composition, comprehension, debugging and modification skills for computer programming. 

Their motivation behind the study was that, whilst widely used in both professional and educational programming enviroments, flowcharts had been found by some researchers to have little improvement on programming skills. For example, Weinberg [3] explains "we find no evidence that the original coding plus flow diagrams is any easier to understand than the original coding itself". However, other reseachers, such as Kammann [4], had found the use of flowcharts to be effective in other sectors, as they helped to seperate relevant information from the irrelevant. 

It seems that, as in Mayer's [5] study, whilst flowcharts may be of help with high-level composition, they do not enhance an individuals comprehension. Therefore, it may be possible for individuals to write the program and ones similar, but transferring their knowledge to other coding tasks will be hindered by a lack of understanding at a lower level.

In all five of the experiments performed by B. Sneiderman et al [2], testing the composition, comprehension, debugging and/or modifcation skills in university students learning programming, found no signficant positive or negative advantages in the use of flowcharts. In one sample, the non-flowchart group outperformed those using flowcharts. It was also observed, in experiment 2, that the subjects rarely made use of the flowcharts, instead working with the program alone. 

In conclusion, whilst the researchers had set out to find the areas of computer programming that flowcharts would be most beneficial to, they found no correlation between flowcharts and increased performance in any of their programming tasks. Whilst more research needs to be done, such as sampling professional programmers, the evidence from this paper puts into question the productiveness of using flowcharts in computer programming, especially in an educational setting.

Reference List:

[1] C.Horsman, S. Stepney, R,C. Wagner and V. Kendon. 2014. When does a physical system compute? Proc. R. Soc. A 470: 20140182. [Online] Available at <a href="www.dx.doi.org/10.1098/rspa.2014.0182">www.rspa.royalsocietypublishing.org</a> [Accessed on 19 September 2016].

[2] B. Shneiderman, R. Mayer, D. McKay and P. Heller. Experimental Investigations of the Utility of Detailed Flowcharts in Programming. Communications of the ACM. Volume 20, Issue 6, June 1977, pp. 373 - 381. [Online] Available at: <a href="http://delivery.acm.org.ezproxy.falmouth.ac.uk/10.1145/360000/359610/p373-shneiderman.pdf?ip=193.61.64.8&id=359610&acc=ACTIVE%20SERVICE&key=BF07A2EE685417C5%2EEAA225A8AB01C582%2E4D4702B0C3E38B35%2E4D4702B0C3E38B35&CFID=864543017&CFTOKEN=41903114&__acm__=1479060359_29217e13cfe7e195550b195869d67ecc">wwww.acm.org</a>  [Accessed on 4 October 2016]

[3] Weinberg, G.M. Tile Psychology of Computer Programming. Van Nostrand, Princeton, N.J., 1971. 

[4] Kammann, R. The comprehensibility of printed instructions and the flowchart alternative. Human Factors 17, 2 (1975), 183-191. 

[5] Mayer, R.E. Different problem-solving competencies established in learning computer programming with and without meaningful models. J. Educ. Psych. 67, 6 (1975), 725-734.
